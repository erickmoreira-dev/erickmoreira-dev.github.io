<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Erick Moreira – Site Pessoal</title>
    <meta
      name="description"
      content="Meu nome é Erick Moreira, sou Desenvolvedor Web e engenheiro de software. Tenho paixão por tudo relacionado à tecnologia, desde engenharia de software e machine learning até UI/UX e gráficos 3D."
    />

    <link rel="icon" type="image/png" href="/icon/32x32.png" />

    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0,viewport-fit=cover"
    />
    <link rel="apple-touch-icon" sizes="180x180" href="/icon/180x180.png" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-title"
      content="Erick Moreira – Personal Website"
    />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="theme-color" content="#f6d4b1" />

    <meta property="og:title" content="Erick Moreira – Personal Website" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="/" />
    <meta property="og:image" content="/icon/og-img1.png" />
    <meta
      name="og:description"
      content="My name is Erick Moreira, I'm a Web Developer and software engineer. I have a passion for all things technology, from software engineering & machine learning to UI/UX & 3D graphics."
    />
    <link rel="manifest" href="/manifest.json" />
    <script type="module" src="/src/main.ts"></script>
    <!-- GSAP CDN para animações -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>
      // Verificar se o GSAP foi carregado corretamente
      document.addEventListener('DOMContentLoaded', function() {
        if (window.gsap) {
          console.log('GSAP carregado com sucesso, versão:', window.gsap.version);
        } else {
          console.error('ERRO: GSAP não foi carregado!');
        }
      });
    </script>
    <style>
      /* Estilos para o GameBoy 3D */
      #gameboy-3d-container {
        position: relative;
        width: 100%;
        height: 100%;
        background-color: #f6d4b1;
      }
      
      .webgl-3d {
        display: block;
        width: 100%;
        height: 100%;
      }

      /* Estilos dos controles do GameBoy 3D */
      .explode-button {
        position: relative;
        display: block;
        margin: 20px auto 0;
        z-index: 10;
        padding: 8px 16px;
        border: 2px solid #000;
        background: #f6d4b1;
        color: #000;
        font-family: monospace;
        cursor: pointer;
        font-size: 14px;
      }
      
      .explode-button:hover {
        background: #ffb54d;
      }

      .ui {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 8px;
        padding: 10px;
        display: flex;
        flex-direction: row;
        gap: 20px;
      }
      
      .ui .group {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 8px;
      }
      
      .ui .label {
        font-size: 12px;
        text-transform: uppercase;
        color: #000;
        margin-right: 5px;
      }
      
      .ui .choice {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 2px solid #000;
        background: #f6d4b1;
        position: relative;
        cursor: pointer;
        padding: 0;
      }
      
      .ui .choice.is-active {
        background: #ffb54d;
      }
      
      .ui .choice .icon {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 14px;
        height: 14px;
      }
      
      .ui .choice.is-mode-plain .icon {
        background: #000;
        border-radius: 50%;
      }
      
      .ui .choice.is-mode-wireframe .icon {
        border: 2px solid #000;
        border-radius: 2px;
        width: 10px;
        height: 10px;
      }

      /* Estilos para o menu e animações */
      .menu-btn {
        position: relative;
        z-index: 100;
      }
      
      .menu-btn .btn {
        transition: transform 0.3s ease-in-out;
      }
      
      nav.active .menu-btn .btn {
        transform: rotate(90deg);
      }
      
      .menu-body {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 0;
        background-color: rgba(246, 212, 177, 0.95);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 99;
        opacity: 0;
        transition: opacity 0.4s ease, height 0.4s ease;
      }
      
      nav.active .menu-body {
        height: 100vh;
        opacity: 1;
      }
      
      .menu-body a {
        margin: 15px 0;
        font-size: 1.5em;
        font-family: "public-pixel", monospace;
        opacity: 0;
        transform: translateY(20px);
        transition: opacity 0.4s ease, transform 0.4s ease;
        transition-delay: 0.1s;
      }
      
      nav.active .menu-body a {
        opacity: 1;
        transform: translateY(0);
      }
      
      nav.active .menu-body a:nth-child(2) {
        transition-delay: 0.2s;
      }
      
      nav.active .menu-body a:nth-child(3) {
        transition-delay: 0.3s;
      }
      
      nav.active .menu-body a:nth-child(4) {
        transition-delay: 0.4s;
      }
      
      /* Melhorar a visibilidade da seta de scroll */
      #tip-scroll {
        position: fixed;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 1.2rem;
        font-weight: bold;
        color: #000;
        background-color: rgba(246, 212, 177, 0.8);
        padding: 10px 20px;
        border-radius: 30px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        z-index: 50;
        animation: bounce 2s infinite;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      
      /* Seta maior e laranja quando o menu está aberto - com !important para garantir prioridade */
      nav.active #tip-scroll {
        font-size: 1.8rem !important;
        color: #fff !important;
        background-color: #ff8c00 !important; /* Cor laranja */
        padding: 15px 30px !important;
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3) !important;
        z-index: 101 !important; /* Valor maior para aparecer acima do menu */
        animation: bounce 1.5s infinite !important; /* Animação mais rápida */
      }
      
      @keyframes bounce {
        0%, 20%, 50%, 80%, 100% {
          transform: translateX(-50%) translateY(0);
        }
        40% {
          transform: translateX(-50%) translateY(-10px);
        }
        60% {
          transform: translateX(-50%) translateY(-5px);
        }
      }

      /* Estilos existentes */
      section {
        padding-bottom: 64px;
        margin-bottom: 80px;
        position: relative;
      }

      section:last-of-type {
        border-bottom: none;
        margin-bottom: 0;
      }
    </style>
  </head>

  <body>
    <div id="home"></div>

    <canvas class="webgl"></canvas>

    <!-- Vídeo para o easter egg hack -->
    <video id="hackVideo" style="display: none;" playsinline>
      <source src="/videos/hacker.mp4" type="video/mp4">
      Seu navegador não suporta o elemento de vídeo.
    </video>

    <div id="hero-backup">
      <h3>Olá, eu sou</h3>
      <h1>Erick Moreira</h1>
      <ul>
        <li>Engenheiro de Software</li>
        <li>Desenvolvedor Web</li>
      </ul>
    </div>

    <nav>
      <div class="menu-btn">
        <button class="btn" onclick="toggleMenu()">
          <svg width="16" height="16">
            <rect class="st0" width="16" height="3.2" />
            <rect y="6.4" class="st0" width="16" height="3.2" />
            <rect y="12.8" class="st0" width="16" height="3.2" />
          </svg>
        </button>
        <div style="display: flex">
          <a
            class="btn"
            href="https://www.linkedin.com/in/erick-moreira-112b3819b/"
            target="_blank"
            rel="noopener noreferrer"
          >
            <svg width="16" height="16">
              <path
                d="M0.1,2c0-1,0.8-1.8,1.9-1.8c1,0,1.8,0.9,1.8,1.8c0,1-0.8,1.9-1.8,1.9C0.9,3.9,0.1,3.1,0.1,2z M0.1,5h3.7v9.8
                H0.1V5z"
              />
              <path
                d="M15.9,8.5v6.2h-3.5V9.4c0-0.9-0.6-1.6-1.5-1.6c-0.8,0-1.4,0.6-1.4,1.5v5.5H5.8V5h3.7v1
                c0.6-0.7,1.6-1.2,2.8-1.2C14.4,4.7,15.9,6.3,15.9,8.5z"
              />
            </svg>
          </a>
          <a
            class="btn"
            href="mailto:erick.moreira@alunos.ifsuldeminas.edu.br"
            target="_blank"
            rel="noopener noreferrer"
          >
            <svg width="16" height="16" viewBox="0 0 24 24">
              <path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
            </svg>
          </a>
          <a
            class="btn"
            href="https://github.com/heryckmp"
            target="_blank"
            rel="noopener noreferrer"
          >
            <svg width="16" height="16">
              <path
                d="M10.6,12.9c0-1-0.3-1.6-0.7-2c2.4-0.3,4.9-1.1,4.9-5.2c0-1.1-0.4-2.1-1.1-2.9c0.1-0.3,0.5-1.3-0.1-2.8
                c0,0-0.9-0.3-3,1.1c-1.7-0.5-3.6-0.5-5.4,0c-2-1.4-3-1.1-3-1.1C1.6,1.4,2,2.5,2.1,2.8C1.4,3.5,1,4.6,1,5.6c0,4.1,2.5,5,4.9,5.3
                c-0.4,0.4-0.6,0.9-0.7,1.4c-0.6,0.3-2.2,0.7-3.1-0.9c0,0-0.6-1-1.6-1.1c0,0-1.1,0-0.1,0.7c0,0,0.7,0.3,1.1,1.6c0,0,0.6,2.1,3.6,1.5
                c0,0.9,0,1.8,0,1.8h5.3C10.6,15.9,10.6,14.4,10.6,12.9z"
              />
            </svg>
          </a>
        </div>
      </div>

      <div class="menu-body" onclick="closeMenu()">
        <a href="#home" onclick="closeMenu()">Início</a>
        <a href="#aboutMe" onclick="closeMenu()">Sobre</a>
        <a href="#projects" onclick="closeMenu()">Projetos</a>
        <a href="#contact" onclick="closeMenu()">Contato</a>
      </div>

      <div id="tip-scroll">Scroll &#8595;</div>
    </nav>

    <main>
      <section>
        <h1 id="aboutMe">Olá</h1>
        <p>
          Meu nome é Erick Moreira, sou Desenvolvedor Web e engenheiro de software. Atualmente estou aprendendo Java e Spring Boot em um programa de ensino da Oracle.
        </p>
        <p>
          Tenho paixão por tudo relacionado à tecnologia, desde engenharia de software e machine learning até UI/UX e gráficos 3D.
        </p>

        <p>
          Além do meu amor por tecnologia e design, também me interesso
          por games e astronomia.
        </p>

        <p>
          Abaixo estão os detalhes de alguns dos projetos que desenvolvi.
        </p>
      </section>

      <section>
        <h1 id="projects">Projetos</h1>
        <hr />
        <h2>OneG8 Bank</h2>
        <h3>2025</h3>
        <ul class="skills">
          <li>React</li>
          <li>TypeScript</li>
          <li>Node.js</li>
          <li>PostgreSQL</li>
          <li>Docker</li>
          <li>AWS</li>
        </ul>
        <p>
          OneG8 é uma solução bancária moderna que oferece uma experiência digital bancária perfeita. A plataforma possui uma interface limpa e intuitiva para gerenciamento de contas, transações em tempo real e autenticação segura. Construída com uma arquitetura de microsserviços, inclui recursos como transferências instantâneas, histórico de transações e análise de contas.
        </p>
        <p>
          O nome do projeto "OneG8" foi inspirado no meu grupo do programa Oracle ONE (Oracle Next Education) - Grupo 8.
        </p>
        <p><a href="https://bank-one-g8.vercel.app" target="_blank" rel="noopener noreferrer">bank-one-g8.vercel.app</a></p>
        <br />
        <div class="image">
          <img
            src="/src/img/oneg8-1.webp"
            width="100%"
            alt="OneG8 Bank screenshot"
            loading="lazy"
            style="aspect-ratio: 16 / 9"
          />
          <video width="100%" controls loop autoplay>
            <source src="/videos/bankg8.mp4" type="video/mp4" />
            Your browser does not support the video tag.
          </video>
        </div>
        <hr />
        <h2>CloudNest</h2>
        <h3>2025</h3>
        <ul class="skills">
          <li>Next.js</li>
          <li>React</li>
          <li>TypeScript</li>
          <li>TailwindCSS</li>
          <li>Appwrite</li>
          <li>Hugging Face AI</li>
        </ul>
        <p>
          CloudNest é uma plataforma moderna de gerenciamento de armazenamento que revoluciona a forma como os usuários interagem com seu conteúdo digital. Construída com as mais recentes tecnologias web, oferece uma experiência segura, intuitiva e descomplicada para gerenciar e compartilhar arquivos na nuvem.
        </p>
        <p>
          A plataforma possui gerenciamento inteligente de arquivos com organização baseada em IA, monitoramento de armazenamento em tempo real, recursos avançados de pesquisa e compartilhamento seguro de arquivos. Inclui recursos como upload por arrastar e soltar, visualização de arquivos e um assistente de IA integrado para melhor interação do usuário.
        </p>
        <p><a href="https://cloud-nest-gray.vercel.app" target="_blank" rel="noopener noreferrer">cloud-nest-gray.vercel.app</a></p>
        <br />
        <div class="image">
          <img
            src="/src/img/cloudnest.png"
            width="100%"
            alt="CloudNest screenshot"
            loading="lazy"
            style="aspect-ratio: 16 / 9"
          />
          <video width="100%" controls loop autoplay>
            <source src="/videos/cloudnest.mp4" type="video/mp4" />
            Your browser does not support the video tag.
          </video>
        </div>
        <hr />
        <h2>ClimateAPP</h2>
        <h3>2025</h3>
        <ul class="skills">
          <li>Next.js 14</li>
          <li>React 18</li>
          <li>TypeScript</li>
          <li>Tailwind CSS</li>
          <li>Three.js</li>
          <li>React-Globe.GL</li>
          <li>Leaflet</li>
        </ul>
        <p>
          ClimateAPP é uma aplicação web moderna para consulta de previsão do tempo, desenvolvida com Next.js e TypeScript. O aplicativo oferece uma interface intuitiva e elegante com efeitos visuais dinâmicos que representam as condições climáticas em tempo real.
        </p>
        <p>
          O aplicativo inclui recursos avançados como busca de cidades com autocompletar, previsão para os próximos 7 dias, detalhes meteorológicos completos, alertas de condições climáticas severas, efeitos visuais dinâmicos baseados no clima, e um globo terrestre 3D interativo com visualização da localização do usuário em tempo real.
        </p>
        <p><a href="https://climate-app-five.vercel.app" target="_blank" rel="noopener noreferrer">climate-app-five.vercel.app</a></p>
        <br />
        <div class="image">
          <img
            src="/src/img/climateapp.png"
            width="100%"
            alt="ClimateAPP screenshot"
            loading="lazy"
            style="aspect-ratio: 16 / 9"
          />
          <video width="100%" controls loop autoplay>
            <source src="/videos/climateapp.mp4" type="video/mp4" />
            Your browser does not support the video tag.
          </video>
        </div>
        <hr />
        <h2>Project L</h2>
        <h3>2025</h3>
        <ul class="skills">
          <li>VR</li>
          <li>Game Dev</li>
          <li>Design</li>
          <li>3D</li>
        </ul>
        <p>
          Ao longo dos anos, criei muitos jogos, com a captura de tela abaixo
          representando um deles. Provavelmente um dos jogos
          tecnicamente mais desafiadores que criei, era um sandbox de mundo aberto em VR
          desenvolvido em Unity, onde você podia interagir, mover, rotacionar e
          redimensionar os objetos no mundo para construir qualquer coisa que desejasse.
        </p>
        <div class="image">
          <img
            src="/src/img/sc3.png"
            width="100%"
            alt="Project L screenshot"
            style="aspect-ratio: 1439 / 896"
          />
          <img
            src="/src/img/sc1.png"
            width="100%"
            alt="Project L screenshot"
            loading="lazy"
            style="aspect-ratio: 1439 / 896"
          />
          <img
            src="/src/img/sc2.png"
            width="100%"
            alt="Project L screenshot"
            loading="lazy"
            style="aspect-ratio: 1439 / 896"
          />
        </div>
        <hr />
        <h2>EnglishAISpeak</h2>
        <h3>2025</h3>
        <ul class="skills">
          <li>Next.js 13+</li>
          <li>TypeScript</li>
          <li>TailwindCSS</li>
          <li>FastAPI</li>
          <li>PostgreSQL</li>
          <li>Python</li>
          <li>LM Studio</li>
          <li>AI</li>
        </ul>
        <p>
          Criei este aplicativo web para meu próprio uso, com o objetivo de treinar inglês usando Inteligência Artificial local através do LM Studio. O projeto oferece uma experiência completa de aprendizado com recursos como conversação em inglês com IA, correções em tempo real, assistente de escrita, prática de pronúncia e acompanhamento de progresso.
        </p>
        <p>
          O aplicativo utiliza modelos de linguagem locais como DeepSeek R1, Mistral e Llama 2 para garantir privacidade dos dados e baixa latência. Inclui recursos avançados como análise detalhada de textos, avaliação fonética, feedback personalizado e um sistema de conquistas para manter os usuários engajados.
        </p>
        <p><a href="https://englishiaspeak.vercel.app" target="_blank" rel="noopener noreferrer">englishiaspeak.vercel.app</a></p>
        <br />
        <div class="image">
          <img
            src="/src/img/treinadoringles.png"
            width="100%"
            alt="EnglishAISpeak screenshot"
            loading="lazy"
            style="aspect-ratio: 16 / 9"
          />
          <video width="100%" controls loop autoplay>
            <source src="/videos/english.mp4" type="video/mp4" />
            Your browser does not support the video tag.
          </video>
        </div>
        <hr />
        <h2>Amigo Secreto</h2>
        <h3>2025</h3>
        <ul class="skills">
          <li>HTML5</li>
          <li>CSS3</li>
          <li>JavaScript</li>
          <li>Speech Synthesis API</li>
          <li>Web Dev</li>
          <li>UI/UX</li>
        </ul>
        <p>
          Este é um projeto simples de "Amigo Secreto" com uma interface de usuário para adicionar amigos e realizar o sorteio. Esse projeto faz parte do curso Iniciante em Programação - Turma G8, do programa Oracle Next Education (ONE).
        </p>
        <p>
          O aplicativo inclui recursos como adição e remoção de participantes, validações de entrada, sorteio automático, síntese de fala para leitura dos resultados, e uma interface responsiva e acessível. Implementa validações robustas como tamanho mínimo de nome, verificação de duplicidade, e quantidade mínima de participantes.
        </p>
        <p><a href="https://amigo-secreto-one-iota.vercel.app" target="_blank" rel="noopener noreferrer">amigo-secreto-one-iota.vercel.app</a></p>
        <br />
        <div class="image">
          <img
            src="/src/img/amigo-secret.png"
            width="100%"
            alt="Amigo Secreto screenshot"
            loading="lazy"
            style="aspect-ratio: 16 / 9"
          />
        </div>
        <hr />
        <p>
          Isso representa apenas uma pequena seleção dos projetos em que trabalhei em 2025.
        </p>
      </section>

      <section>
        <h1 id="contact">Contato</h1>
        <p style="text-align: center">
          Entre em contato pelo
          <a href="https://www.linkedin.com/in/erick-moreira-112b3819b/"
            target="_blank"
            rel="noopener noreferrer"
          ><u><b>LinkedIn</b></u></a
          >
        </p>
        
        <!-- GameBoy 3D integrado na seção de contato -->
        <div style="position: relative; width: 100%; max-width: 800px; height: 600px; margin: 30px auto;">
          <div id="gameboy-3d-container">
            <canvas class="webgl-3d"></canvas>
          </div>
          <button class="explode-button">SPACE para EXPLODIR</button>
        </div>
      </section>

      <footer>
        <p>Design do computador baseado no Commodore PET 8296 - Um computador pessoal clássico de 1981, com monitor monocromático embutido e teclado mecânico. Um dos primeiros designs all-in-one que influenciou a computação moderna.</p>
        <p>DIREITOS AUTORAIS © 2022-2024 Erick M.</p>
      </footer>
    </main>

    <input type="text" id="textarea" readonly />
    <div id="loading">
      <h2>Booting...</h2>
      <div id="loading-bar">
        <div id="loading-bar-progress"></div>
      </div>
      <div id="loading-items">Starting...</div>
    </div>
    <script>
      function closeMenu() {
        document.getElementsByTagName("nav")[0].classList.remove("active");
        
        // Resetar estilos da seta quando o menu é fechado
        const scrollTip = document.getElementById('tip-scroll');
        scrollTip.style.fontSize = '';
        scrollTip.style.color = '';
        scrollTip.style.backgroundColor = '';
        scrollTip.style.padding = '';
        scrollTip.style.boxShadow = '';
        scrollTip.style.zIndex = '';
        
        // Verificar se deve esconder a seta baseado na posição de rolagem
        if (window.scrollY > 100) {
          scrollTip.style.opacity = '0';
          scrollTip.style.pointerEvents = 'none';
        }
      }

      function toggleMenu() {
        const nav = document.getElementsByTagName("nav")[0];
        nav.classList.toggle("active");
        
        // Certifique-se de que a seta está visível e estilizada corretamente quando o menu estiver aberto
        const scrollTip = document.getElementById('tip-scroll');
        
        if (nav.classList.contains("active")) {
          // Aplicar estilos diretamente via JavaScript para garantir que serão aplicados
          scrollTip.style.opacity = '1';
          scrollTip.style.pointerEvents = 'auto';
          scrollTip.style.fontSize = '1.8rem';
          scrollTip.style.color = '#fff';
          scrollTip.style.backgroundColor = '#ff8c00';
          scrollTip.style.padding = '15px 30px';
          scrollTip.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.3)';
          scrollTip.style.zIndex = '101';
        } else {
          // Resetar estilos se o menu for fechado
          scrollTip.style.fontSize = '';
          scrollTip.style.color = '';
          scrollTip.style.backgroundColor = '';
          scrollTip.style.padding = '';
          scrollTip.style.boxShadow = '';
          scrollTip.style.zIndex = '';
          
          // Verificar se deve esconder a seta baseado na posição de rolagem
          if (window.scrollY > 100) {
            scrollTip.style.opacity = '0';
            scrollTip.style.pointerEvents = 'none';
          }
        }
      }
      
      // Adiciona funcionalidade para a seta de scroll
      document.addEventListener('DOMContentLoaded', function() {
        const scrollTip = document.getElementById('tip-scroll');
        if (scrollTip) {
          scrollTip.addEventListener('click', function() {
            window.scrollTo({
              top: window.innerHeight, 
              behavior: 'smooth'
            });
            
            // Fecha o menu quando a seta é clicada
            const nav = document.getElementsByTagName("nav")[0];
            if (nav.classList.contains("active")) {
              closeMenu();
            }
          });
          
          // Esconde a seta depois de rolar, mas apenas se o menu não estiver aberto
          window.addEventListener('scroll', function() {
            const nav = document.getElementsByTagName("nav")[0];
            
            if (window.scrollY > 100 && !nav.classList.contains("active")) {
              scrollTip.style.opacity = '0';
              scrollTip.style.pointerEvents = 'none';
            } else {
              scrollTip.style.opacity = '1';
              scrollTip.style.pointerEvents = 'auto';
              
              // Se o menu estiver aberto, garantir que a seta mantenha o estilo laranja
              if (nav.classList.contains("active")) {
                scrollTip.style.fontSize = '1.8rem';
                scrollTip.style.color = '#fff';
                scrollTip.style.backgroundColor = '#ff8c00';
                scrollTip.style.padding = '15px 30px';
                scrollTip.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.3)';
                scrollTip.style.zIndex = '101';
              }
            }
          });
        }
      });
    </script>
    <script
      fetchpriority="high"
      src="https://cdn-ts.netlify.app/webgl-helper@3.0.11/webgl-helper.min.js"
    ></script>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-EDNKHGV4HB"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());
      gtag("config", "G-EDNKHGV4HB");
      gtag("event", "origin", { name: window.origin });
    </script>

    <button onclick="toggleTranslate()" class="translate-btn" id="translate-btn" style="display: none;">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"/>
      </svg>
      Translate
    </button>

    <script>
      // Mostrar botão de tradução depois que sair da tela do PC
      window.addEventListener('scroll', function() {
        const computerScreen = document.querySelector('.webgl');
        const translateBtn = document.getElementById('translate-btn');
        
        if (window.scrollY > window.innerHeight) {
          translateBtn.style.display = 'flex';
        } else {
          translateBtn.style.display = 'none';
        }
      });

      // Função para alternar o Google Translate
      function toggleTranslate() {
        const translateBtn = document.getElementById('translate-btn');
        
        if (!window.googleTranslateElementInit) {
          // Primeira vez que o botão é clicado
          window.googleTranslateElementInit = function() {
            new google.translate.TranslateElement({
              pageLanguage: 'pt',
              includedLanguages: 'en',
              layout: google.translate.TranslateElement.InlineLayout.SIMPLE
            }, 'google_translate_element');
          }

          // Adiciona o elemento do Google Translate
          const div = document.createElement('div');
          div.id = 'google_translate_element';
          div.style.position = 'fixed';
          div.style.bottom = '80px';
          div.style.right = '20px';
          div.style.zIndex = '1000';
          document.body.appendChild(div);

          // Carrega o script do Google Translate
          const script = document.createElement('script');
          script.src = '//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit';
          document.body.appendChild(script);

          translateBtn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
              <path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"/>
            </svg>
            Translate`;
        } else {
          // Remove o widget de tradução
          const element = document.getElementById('google_translate_element');
          if (element) element.remove();
          
          // Reseta a página para o idioma original
          const iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
          if (iframe) {
            iframe.contentWindow.document.getElementsByTagName('button')[0].click();
          }
          
          // Remove a função init
          delete window.googleTranslateElementInit;
          
          translateBtn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
              <path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"/>
            </svg>
            Translate`;
        }
      }
    </script>

    <!-- Script do GameBoy 3D -->
    <script type="module">
      import * as THREE from 'three';
      import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
      import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';
      // Remover importação local do GSAP e usar variável global
      import WebGL from '/src/webgl';

      class GameBoy3D {
        constructor() {
          this.init();
        }

        async init() {
          // Initialize Three.js scene
          this.setupScene();
          
          // Setup environment maps
          await this.setupEnvironment();

          // Load assets
          await this.loadAssets();

          // Setup Cartridge components
          this.setupCartridge();

          // Setup controls and inputs
          this.setupControls();

          // Setup Audio
          this.setupAudio();

          // Start animation loop
          this.animate();
        }

        setupScene() {
          // Canvas
          this.canvas = document.querySelector('.webgl-3d');

          // Scene
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color('#f6d4b1');

          const container = document.getElementById('gameboy-3d-container');
          const width = container.clientWidth;
          const height = container.clientHeight;

          // Camera
          this.camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 1000);
          this.camera.position.set(0, 0, 13);
          this.scene.add(this.camera);

          // Renderer
          this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            antialias: true,
            alpha: true,
            powerPreference: 'high-performance'
          });
          this.renderer.setSize(width, height);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          this.renderer.outputEncoding = THREE.sRGBEncoding;
          this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
          this.renderer.toneMappingExposure = 1.2;
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          this.renderer.physicallyCorrectLights = true;
          
          // Controls
          this.controls = new OrbitControls(this.camera, this.canvas);
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          this.controls.enableZoom = true;
          this.controls.minDistance = 4;
          this.controls.maxDistance = 15;
          this.controls.maxPolarAngle = Math.PI / 1.5;
          this.controls.minPolarAngle = Math.PI / 4;
          
          // Adiciona flag para controlar se o mouse está se movendo
          this.controls.isMouseMoving = false;
          
          this.canvas.addEventListener('pointerdown', () => {
            this.controls.isMouseMoving = true;
          });
          
          this.canvas.addEventListener('pointerup', () => {
            this.controls.isMouseMoving = false;
          });
          
          this.canvas.addEventListener('pointermove', () => {
            if (this.controls.isMouseMoving) {
              this.controls.isMouseMoving = true;
            }
          });
          
          // Set initial camera target
          this.controls.target.set(0, 0, 0);
          this.controls.update();

          // Handle resize
          window.addEventListener('resize', () => {
            const container = document.getElementById('gameboy-3d-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Update camera
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();

            // Update renderer
            this.renderer.setSize(width, height);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          });
        }

        async setupEnvironment() {
          return new Promise((resolve) => {
            // Carregar o mapa de ambiente HDR
            const rgbeLoader = new RGBELoader();
            rgbeLoader.load('/envMaps/custom-002.hdr', (texture) => {
              texture.mapping = THREE.EquirectangularReflectionMapping;
              this.scene.environment = texture;
              
              // Configurar iluminação adicional
              const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
              this.scene.add(ambientLight);

              const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
              directionalLight.position.set(1, 2, 3);
              directionalLight.castShadow = true;
              directionalLight.shadow.mapSize.width = 1024;
              directionalLight.shadow.mapSize.height = 1024;
              directionalLight.shadow.camera.near = 0.1;
              directionalLight.shadow.camera.far = 20;
              directionalLight.shadow.normalBias = 0.02;
              this.scene.add(directionalLight);
              
              resolve();
            }, undefined, (error) => {
              console.warn('Failed to load environment map, using fallback lighting');
              const ambientLight = new THREE.AmbientLight(0xffffff, 1);
              this.scene.add(ambientLight);
              resolve();
            });
          });
        }

        async loadAssets() {
          return new Promise((resolve) => {
            const loadingManager = new THREE.LoadingManager();
            
            // Criar um grupo pai para todos os componentes
            this.gameboyGroup = new THREE.Group();
            this.scene.add(this.gameboyGroup);
            
            let loadedCount = 0;
            const totalModels = 4; // case, circuit, screw, sticker
            
            const checkAllLoaded = () => {
              loadedCount++;
              if (loadedCount === totalModels) {
                resolve();
              }
            };
            
            // Inicialize o loader do GLTF
            this.gltfLoader = new GLTFLoader(loadingManager);
            
            // Carregue o modelo do case
            this.gltfLoader.load('/models/case.glb', (gltf) => {
              this.gameboy = gltf.scene;
              console.log("Case model loaded:", this.gameboy);
              
              // Aplicar material de vidro às cases do GameBoy
              this.gameboy.traverse(child => {
                if (child.isMesh) {
                  // Cor base do GameBoy (preservando a cor original)
                  const originalColor = child.material.color 
                    ? new THREE.Color(child.material.color.r, child.material.color.g, child.material.color.b)
                    : new THREE.Color(0xf0ead6); // Cor que corresponde ao GameBoy original
                  
                  // Cores para os reflexos mais sutis e naturais
                  const blueReflection = new THREE.Color(0x84a9c0); // Azul mais suave/pastel
                  const pinkReflection = new THREE.Color(0xdcacb9); // Rosa mais suave/pastel
                  
                  // Material de vidro com reflexos mais naturais
                  const glassMaterial = new THREE.MeshPhysicalMaterial({
                    color: originalColor,
                    metalness: 0.1,           // Reduzido para menos metalicidade
                    roughness: 0.1,           // Ligeiramente aumentado para reflexos mais naturais
                    transmission: 0.85,
                    transparent: true,
                    opacity: 0.75,
                    envMapIntensity: 1.2,     // Reduzido para reflexos menos intensos
                    clearcoat: 0.6,           // Reduzido para um efeito mais natural
                    clearcoatRoughness: 0.2,  // Aumentado para dispersar o brilho
                    ior: 1.45,
                    thickness: 0.5,
                    attenuationColor: pinkReflection, // Cor rosa mais suave
                    attenuationDistance: 0.8,  // Aumentado para efeito mais sutil
                    specularIntensity: 0.7,    // Reduzido para menor intensidade
                    specularColor: blueReflection, // Cor azul mais suave
                    iridescence: 0.05,         // Drasticamente reduzido
                    iridescenceIOR: 1.3,
                    sheen: 0.1,                // Drasticamente reduzido
                    sheenRoughness: 0.8,       // Aumentado para dispersar o efeito
                    sheenColor: pinkReflection  // Mantendo o rosa suave
                  });
                  
                  // Preservar texturas originais
                  if (child.material.map) glassMaterial.map = child.material.map;
                  if (child.material.normalMap) glassMaterial.normalMap = child.material.normalMap;
                  
                  // Aplicar material e configurar sombras
                  child.material = glassMaterial;
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              
              this.gameboyGroup.add(this.gameboy);
              checkAllLoaded();
            });

            // Carregue o modelo do circuito
            this.gltfLoader.load('/models/circuit.glb', (gltf) => {
              this.circuit = gltf.scene;
              console.log("Circuit model loaded:", this.circuit);
              
              this.circuit.traverse(child => {
                if (child.isMesh && child.material) {
                  child.material.envMapIntensity = 1.5;
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              
              this.gameboyGroup.add(this.circuit);
              checkAllLoaded();
            });

            // Carregue o modelo dos parafusos
            this.gltfLoader.load('/models/screw.glb', (gltf) => {
              this.screw = gltf.scene;
              console.log("Screw model loaded:", this.screw);
              
              this.screw.traverse(child => {
                if (child.isMesh && child.material) {
                  child.material.envMapIntensity = 2.5;
                  child.material.metalness = 1.0;
                  child.material.roughness = 0.2;
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              
              this.gameboyGroup.add(this.screw);
              checkAllLoaded();
            });

            // Carregue o modelo do sticker
            this.gltfLoader.load('/models/sticker.glb', (gltf) => {
              this.sticker = gltf.scene;
              console.log("Sticker model loaded:", this.sticker);
              
              this.sticker.traverse(child => {
                if (child.isMesh && child.material) {
                  child.material.envMapIntensity = 0.8;
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              
              this.gameboyGroup.add(this.sticker);
              checkAllLoaded();
            });

            // Load audio
            const audioLoader = new THREE.AudioLoader(loadingManager);
            audioLoader.load('/sounds/debrisOpening.mp3', (buffer) => {
              this.openingSound = buffer;
            });
            
            audioLoader.load('/sounds/debrisClosing.mp3', (buffer) => {
              this.closingSound = buffer;
            });
          });
        }

        setupCartridge() {
          // Position adjustments for cartridge components
          if (this.gameboy) {
            this.gameboy.position.set(0, 0, 0);
            this.gameboy.traverse(child => {
              if (child.isMesh && child.material) {
                child.material.envMapIntensity = 1.2;
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
          }

          if (this.sticker) {
            // Ajustar posição e escala do sticker
            this.sticker.position.set(0, 0, 0.05); // Mais próximo da superfície
            this.sticker.scale.set(1.04, 1.04, 1); // Escala reduzida para encaixar melhor no quadrado
            
            this.sticker.traverse(child => {
              if (child.isMesh && child.material) {
                // Ajustes do material para melhor visibilidade
                child.material.envMapIntensity = 0.8;
                child.material.depthWrite = true;
                child.material.polygonOffset = true;
                child.material.polygonOffsetFactor = -1;
                child.material.polygonOffsetUnits = -1;
                child.material.transparent = false;
                child.material.opacity = 1;
                child.material.side = THREE.FrontSide;
                child.renderOrder = 2;
                
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
          }

          // Ajustar posição do circuito
          if (this.circuit) {
            this.circuit.position.set(0, 0, -0.1); // Movido mais para trás
            this.circuit.traverse(child => {
              if (child.isMesh && child.material) {
                child.material.envMapIntensity = 1.5;
                child.renderOrder = 0;
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
          }

          // Ajustar posição dos parafusos
          if (this.screw) {
            this.screw.position.set(0, 0, -0.05); // Ajustado para alinhar melhor com o case
            this.screw.traverse(child => {
              if (child.isMesh && child.material) {
                child.material.envMapIntensity = 2.5;
                child.material.metalness = 1.0;
                child.material.roughness = 0.2;
                child.renderOrder = 1;
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
          }

          // Ajustar posição do grupo pai
          if (this.gameboyGroup) {
            this.gameboyGroup.position.set(0, 0, 0);
            this.gameboyGroup.rotation.set(0, 0, 0);
          }
        }

        setupAudio() {
          // Create an audio listener and add it to the camera
          this.audioListener = new THREE.AudioListener();
          this.camera.add(this.audioListener);
          
          // Create a global audio source
          this.sound = new THREE.Audio(this.audioListener);
          
          // Load audio files
          const audioLoader = new THREE.AudioLoader();
          audioLoader.load('/sounds/debrisOpening.mp3', (buffer) => {
            this.openingSound = buffer;
          });
          
          audioLoader.load('/sounds/debrisClosing.mp3', (buffer) => {
            this.closingSound = buffer;
          });
        }

        saveComponentOriginalState(component) {
          if (!component.originalState) {
            component.originalState = {
              position: component.position.clone(),
              rotation: component.rotation.clone(),
              scale: component.scale.clone()
            };
          }
        }

        restoreComponentToOriginalState(component) {
          if (component.originalState) {
            window.gsap.to(component.position, {
              duration: 1.5,
              x: component.originalState.position.x,
              y: component.originalState.position.y,
              z: component.originalState.position.z,
              ease: "power2.inOut"
            });

            window.gsap.to(component.rotation, {
              duration: 1.9,
              x: component.originalState.rotation.x,
              y: component.originalState.rotation.y,
              z: component.originalState.rotation.z,
              ease: "power2.inOut"
            });
          }
        }

        toggleExplodedView() {
          const isExploding = this.isExploded;
          
          // Play sound effect
          if (this.sound) {
            const soundBuffer = isExploding ? this.openingSound : this.closingSound;
            if (soundBuffer) {
              this.sound.setBuffer(soundBuffer);
              this.sound.setVolume(0.5);
              if (this.sound.isPlaying) {
                this.sound.stop();
              }
              this.sound.play();
            }
          }

          // Save original states if not already saved
          if (!this.statesAreSaved) {
            this.statesAreSaved = true;
            
            // Save states for all components
            const saveState = (component) => {
              if (!component) return;
              
              component.traverse((child) => {
                if (child.isMesh) {
                  if (!child.userData.originalState) {
                    child.userData.originalState = {
                      position: child.position.clone(),
                      rotation: child.rotation.clone()
                    };
                  }
                }
              });
            };

            // Save states for all major components
            saveState(this.screw);
            saveState(this.gameboy);
            saveState(this.sticker);
            saveState(this.circuit);
          }

          // Animate screws
          if (this.screw) {
            this.screw.traverse((child) => {
              if (child.isMesh && child.userData.originalState) {
                if (isExploding) {
                  window.gsap.to(child.rotation, {
                    z: -Math.PI * 2,
                    duration: 2.0,
                    ease: "power1.inOut",
                    delay: 0
                  });

                  window.gsap.to(child.position, {
                    z: child.position.z - 2.7,
                    duration: 2.0,
                    ease: "power2.out",
                    delay: 0
                  });
                } else {
                  window.gsap.to(child.position, {
                    x: child.userData.originalState.position.x,
                    y: child.userData.originalState.position.y,
                    z: child.userData.originalState.position.z,
                    duration: 2.0,
                    ease: "power2.inOut",
                    delay: 2.5  // Increased delay for assembly
                  });

                  window.gsap.to(child.rotation, {
                    x: child.userData.originalState.rotation.x,
                    y: child.userData.originalState.rotation.y,
                    z: child.userData.originalState.rotation.z,
                    duration: 2.0,
                    ease: "power2.inOut",
                    delay: 2.0  // Increased delay for assembly
                  });
                }
              }
            });
          }

          // Animate case
          if (this.gameboy) {
            let frontPart = null;
            let backPart = null;

            this.gameboy.traverse((child) => {
              if (child.isMesh) {
                if (!child.userData.originalState) {
                  child.userData.originalState = {
                    position: child.position.clone(),
                    rotation: child.rotation.clone()
                  };
                }

                if (child.name.toLowerCase().includes('front') || child.position.z > 0) {
                  frontPart = child;
                } else if (child.name.toLowerCase().includes('back') || child.position.z <= 0) {
                  backPart = child;
                }
              }
            });

            if (frontPart && backPart) {
              if (isExploding) {
                window.gsap.to(frontPart.position, {
                  z: frontPart.position.z + 2.0,
                  duration: 2.5,
                  ease: "power2.inOut",
                  delay: 1.2
                });

                window.gsap.to(backPart.position, {
                  z: backPart.position.z - 2.0,
                  duration: 2.5,
                  ease: "power2.inOut",
                  delay: 1.2
                });
              } else {
                window.gsap.to(frontPart.position, {
                  x: frontPart.userData.originalState.position.x,
                  y: frontPart.userData.originalState.position.y,
                  z: frontPart.userData.originalState.position.z,
                  duration: 2.5,
                  ease: "power2.inOut",
                  delay: 1.2
                });

                window.gsap.to(backPart.position, {
                  x: backPart.userData.originalState.position.x,
                  y: backPart.userData.originalState.position.y,
                  z: backPart.userData.originalState.position.z,
                  duration: 2.5,
                  ease: "power2.inOut",
                  delay: 1.2
                });
              }
            }
          }

          // Animate sticker
          if (this.sticker) {
            if (!this.sticker.userData.originalState) {
              this.sticker.userData.originalState = {
                position: this.sticker.position.clone(),
                rotation: this.sticker.rotation.clone()
              };
            }

            if (isExploding) {
              window.gsap.to(this.sticker.position, {
                z: this.sticker.position.z + 3.0,
                duration: 2.0,
                ease: "power2.out",
                delay: 0.8
              });
            } else {
              window.gsap.to(this.sticker.position, {
                x: this.sticker.userData.originalState.position.x,
                y: this.sticker.userData.originalState.position.y,
                z: this.sticker.userData.originalState.position.z,
                duration: 2.0,
                ease: "power2.inOut",
                delay: 2.3  // Increased delay for assembly
              });
            }
          }

          // Animate circuit components
          if (this.circuit) {
            this.circuit.traverse((child) => {
              if (child.isMesh) {
                if (!child.userData.originalState) {
                  child.userData.originalState = {
                    position: child.position.clone(),
                    rotation: child.rotation.clone()
                  };
                }

                if (isExploding) {
                  const randomDelay = Math.random() * 0.3;
                  const randomDistance = 0.8 + (Math.random() * 0.4);

                  window.gsap.to(child.position, {
                    z: child.position.z + (0.7 * randomDistance),
                    duration: 2.0,
                    ease: "power2.out",
                    delay: 1.5 + randomDelay
                  });
                } else {
                  window.gsap.to(child.position, {
                    x: child.userData.originalState.position.x,
                    y: child.userData.originalState.position.y,
                    z: child.userData.originalState.position.z,
                    duration: 2.0,
                    ease: "power2.inOut",
                    delay: 1.5 + (Math.random() * 0.2)
                  });
                }
              }
            });
          }
        }

        animate() {
          let lastInteractionTime = Date.now();
          let isRotating = true;

          const animate = () => {
            requestAnimationFrame(animate);
            
            try {
              // Update controls
              if (this.controls) {
                this.controls.update();
                
                // Se os controles estiverem sendo usados, atualiza o tempo da última interação
                if (this.controls.isMouseMoving) {
                  lastInteractionTime = Date.now();
                  isRotating = false;
                } else {
                  // Verifica se passaram 5 segundos desde a última interação
                  const timeSinceLastInteraction = Date.now() - lastInteractionTime;
                  if (timeSinceLastInteraction >= 5000) {
                    isRotating = true;
                  }
                }
              }
              
              // Rotação do grupo quando não explodido e permitido rotacionar
              if (!this.isExploded && this.gameboyGroup && isRotating) {
                this.gameboyGroup.rotation.y += 0.0025;
              }
              
              // Render scene
              if (this.renderer && this.scene && this.camera) {
                this.renderer.render(this.scene, this.camera);
              }
            } catch (error) {
              console.error('Error in animation:', error);
            }
          };
          
          animate();
        }

        setupControls() {
          // Controls for exploding/imploding the cartridge
          this.isExploded = false;
          
          document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
              this.isExploded = !this.isExploded;
              this.toggleExplodedView();
              this.updateExplodeButtonText();
            }
          });
          
          // Add button listener for mobile devices
          this.explodeButton = document.querySelector('#gameboy-3d-container + .explode-button');
          if (this.explodeButton) {
            this.explodeButton.addEventListener('click', () => {
              this.isExploded = !this.isExploded;
              this.toggleExplodedView();
              this.updateExplodeButtonText();
            });
          }

          // OrbitControls setup
          this.controls = new OrbitControls(this.camera, this.canvas);
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          this.controls.enableZoom = true;
          this.controls.minDistance = 4;
          this.controls.maxDistance = 15;
          this.controls.maxPolarAngle = Math.PI / 1.5;
          this.controls.minPolarAngle = Math.PI / 4;
          
          // Adiciona flag para controlar se o mouse está se movendo
          this.controls.isMouseMoving = false;
          
          this.canvas.addEventListener('pointerdown', () => {
            this.controls.isMouseMoving = true;
          });
          
          this.canvas.addEventListener('pointerup', () => {
            this.controls.isMouseMoving = false;
          });
          
          this.canvas.addEventListener('pointermove', () => {
            if (this.controls.isMouseMoving) {
              this.controls.isMouseMoving = true;
            }
          });
          
          // Set initial camera target
          this.controls.target.set(0, 0, 0);
          this.controls.update();
        }

        updateExplodeButtonText() {
          if (this.explodeButton) {
            this.explodeButton.textContent = `SPACE para ${this.isExploded ? 'IMPLODIR' : 'EXPLODIR'}`;
          }
        }
      }

      // Initialize GameBoy 3D when the section is visible
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            console.log("GameBoy section is visible, initializing animation");
            // Create new GameBoy3D instance if it doesn't exist
            if (!entry.target.gameboy) {
              console.log("Creating new GameBoy3D instance");
              entry.target.gameboy = new GameBoy3D();
              
              // Define uma função para executar a animação de explosão/implosão
              const runExplodeAnimation = () => {
                // Verificar se o GameBoy está pronto para ser animado
                if (!entry.target.gameboy.gameboyGroup || !entry.target.gameboy.toggleExplodedView) {
                  console.error("GameBoy não está pronto para animação");
                  return;
                }
                
                console.log("Starting automatic explosion animation");
                // Trigger explosion
                entry.target.gameboy.isExploded = true;
                entry.target.gameboy.toggleExplodedView();
                entry.target.gameboy.updateExplodeButtonText();
                
                // Trigger implosion after 3 seconds
                setTimeout(() => {
                  console.log("Starting automatic implosion animation");
                  entry.target.gameboy.isExploded = false;
                  entry.target.gameboy.toggleExplodedView();
                  entry.target.gameboy.updateExplodeButtonText();
                }, 3000);
              };
              
              // Executar a animação pela primeira vez após 2 segundos
              setTimeout(runExplodeAnimation, 2000);
              
              // Configurar animação automática periódica a cada 30 segundos
              entry.target.gameboy.autoAnimationInterval = window.setInterval(() => {
                // Verificar se o elemento está visível na página
                const rect = document.getElementById('gameboy-3d-container').getBoundingClientRect();
                const isVisible = (
                  rect.top >= 0 &&
                  rect.left >= 0 &&
                  rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                  rect.right <= (window.innerWidth || document.documentElement.clientWidth)
                );
                
                if (isVisible) {
                  runExplodeAnimation();
                }
              }, 30000); // Repetir a cada 30 segundos
            }
          } else {
            // Se saiu da visualização, limpar intervalo de animação automática
            if (entry.target.gameboy && entry.target.gameboy.autoAnimationInterval) {
              window.clearInterval(entry.target.gameboy.autoAnimationInterval);
            }
          }
        });
      }, { threshold: 0.2 });

      // Observe the GameBoy 3D section
      document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM loaded, setting up GameBoy observer");
        const container = document.getElementById('gameboy-3d-container');
        if (container) {
          console.log("GameBoy container found, starting observation");
          observer.observe(container);
        } else {
          console.error("GameBoy container not found!");
        }
      });

      loadAssists((assists) => {
        const stats = new Stats();
        // ... existing code ...

        const screen = Screen(assists, renderer);

        // Manipulador do vídeo hack
        WebGL.setupHackVideo(assists);

        // ... rest of the code ...
      });
    </script>
  </body>
</html>
